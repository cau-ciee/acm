15. Dynamic Programming
    So, the topic today is dynamic programming(我们今天来讲动态规划).The term programming in the name of this term(本质上来说 这里的“编程”)doesn't refer to computer programming(并不是指实际的计算机编程).OK, programming is an old word that means(其实 编程这个名词的本意是)any tabular method for accomplishing something(按照一定的步骤来解决问题).So, you'll hear about linear programming(你们可能已经听说过线性规划)and dynamic programming(和动态规划).Either of those, even though we now incorporate(无论哪个 尽管我们现在在编程中)those algorithms in computer programs,(使用这些算法)originally computer programming(但在实际计算机编程中), you were given a datasheet and you put(你要做的是写出一行一行的)one line per line of code as a tabular method(能够按步骤执行的代码)for giving the machine instructions as to what to do.(这样电脑才会明白如何执行这项工作)OK, so the term programming is older.(这里说的“编程”是以前的表达方式了)Of course, and now conventionally when you see programming(当然 按照惯例我们说编程的时候)you mean software, computer programming.(指的是电脑程序的编程)But that wasn't always the case.(哦 严格来说倒也不一定)And these terms continue in the literature.(文献上说的编程还是将他的本意)So, dynamic programming is a design technique like other(动态规划就是一种设计的技巧)design technique we've seen such as divided and conquer.(就像我们以前讲过的分而治之法)OK, so it's a way of solving a class of problems(也就是说它是解决一类问题的方法)rather than a particular algorithms or something.(而不是某种固定的算法)
    So, we're going to work through this for the example of(所以 我们通过一个具体的例子来学习这种方法)so-called longest common subsequence problem(就是传说中的最长公共子序列问题)sometimes called LCS.which is a problem that comes up in a variety of contexts.(这个问题在很多地方都会出现)And it's particularly important in computation biology(在计算生物学里尤为重要)where you have long DNA strains and you're trying to(比如你想在一些DNA长链里)find commonalities between two strings(找到两条链里相同的部分)OK, one which may be a genome and one may be various(比如其中一段序列是基因组序列)when people do, what is that thing called(他们是用什么东西)when they do the evolutionary comparisons?(来表示演化过程的比较的？)So, you're given two sequences, x going from one to m(给定两个序列 x是从1到m)and y running from one to n(y从1到n)Usually the longest common subsequence isn't unique.(但通常 最长公共子序列并不唯一)There could be several different subsequences(可能有很多子序列).However, people tend to, it's one of the sloppinesses(不过通常情况下)that people will say.(大家都说得不太严谨).I will try to say a, unless it's unique(我习惯说“之一”除非最长公共子序列的确只有一个)
    So, here's an example.(现在来看例子吧)Suppose x is this sequence, and y is this sequence.(令x是这个序列 y是这个序列)So, what is a longest common subsequence.(所以，最长公共子序列是？)
    So let's analyze that(分析一下).what's the time of Check,Length of y, which is order n.And how do you do it?(就是y的长度O(n))，你怎么知道的？Yeah, you just scan(是的 就是扫描一遍).Now, if you will, recursively see whether(那就按x和y的下标开始递归)the suffix of your string matches the suffix of x(判断x和y里对应的元素是否相同).OK, and so, you are just simply walking down the tree(总而言之 就是顺着撸一遍)to see if it matches(看看有没有相同的).You're walking down the string to see if it matches(遍历这个字符串 看看有没有相同的).OK, then the second thing is(第二个问题是)then how many subsequences of x are there(X有多少子序列)?Two to the n(2^n)?x just goes from one to m, two to the m subsequences of x(x是从1到m 也就是说x的子序列有2^m个).Two to the m subsequences of x(x的子序列有2^m个).OK, one way to see that, you say, well(有一种方法来计算),how many subsequences are there of something there(某个序列的子序列有多少个)?If I consider a bit vector of length m(考虑一个长度为m的“位向量”实际上就是二进制数，用1和0来表示对应位上的元素).OK, that's one or zero,just every position where there's a one, I take out,(如果有一个元素被标记为1)that identifies an element that I'm going to take out(那就表示这个元素被我放进了子序列里).OK, then that gives me a mapping from each subsequence of x(这样我就可以得到一个映射 每个x的子序列)from each bit vector to a different subsequence of x(都对应了一个相应的位向量).Now, of course, you could have matching characters there(当然 有的子序列的字符可能是相同的),but in the worst case, all of the characters are different(不过在最坏情况下 所有的字符都是不一样的).OK, and so every one of thos will be a unique subsequence(那样每个子序列都是不同的).So, each bit vector of length m corresponds to a subsequence(所以每个长为m的位向量 都对应了一个子序列).So, the worst-case running time of this method(于是这个方法在最坏条件下的运行时间)is order n times two to the m, which is,(就是O(n*2^m)也就是说)since m is in the exponent, is exponential time(由于m在指数位上 运行时间也就是指数阶的).And there's a technical term that we use(我们可以用一个术语)when something is exponential time(描述指数阶时间).Slow, good.(龟速 好的)This is taking a long time to crank out(这样做需要花费相当长的时间)how long the longest common subsequence is(才能算出最长公共子序列的长度)because there's so many subsequences(因为子序列实在是太多了).OK, so we're going to now go through a process of(那么我们现在需要设计)developing a far more efficient algorithm for this problem(一种更给力的算法来解决这个问题).
    OK, and we're actually going to go through several stages(可以分为几个步骤).The first one is to go through simplification stage(第一步是进行简化).OK, and what we're going to do is look at simply(我们来分别看看)the length of the longest common sequence of x and y(x和y的LCS有多长).And then what we'll do is extend the algorithm(我们要做的就是扩展这个算法)to find the longest common subsequence itself(使之能够找到最长公共子序列).OK, so we're going to look at the length(我们从序列的长度入手).So, simplify the problem, if you will,(那么先试着简化计算)to just try to compute the length(LCS长度这个问题).What's nice is the length is unique(令人愉快的是 这个长度是唯一的).OK, there's only going to be one length(所谓的最大长度) that's going to be the longest(有且仅有一个).OK, and what we'll do is just focus on(于是我们现在要做的就是)the problem of computing the length(如何计算LCS的长度).And then we'll do is we can back up from that and figure out(然后我们再回头来看看)what actually is the subsequence that realizes that length(哪个公共子区间达到了这个长度).OK, and that will be a big simplification because we don't(这样做就简化了很多)have to keep track of a lot of different possibilities(因为我们无需在意其他的可能性)at every stage. We just have to keep track of(我们要做的就是记录)the one number,which is the length(一个最大长度的数值).So, it's sort of reduces it to a numerical problem(这样就把它简化成了一个数值问题).We'll adopt the following notation(我们会用到这样的符号).It's pretty standard notation,but I just want,(这个符号很常见 不过在这里)if I put absolute values around the string or a sequence(如果我对一个序列加了绝对值符号),it denotes the length of the sequence, S(它表示的是这个序列的长度 S).OK, so that's the first thing.The second thing we're going to(嗯这是第一点 接下来我们要做的)do is, actually, we're going to(我们要做的－－－),which takes a lot more insight when you come up with(对付这样的问题需要你的优化意识)a problem like this, and in some sense(从某种意义上来说),ends up being the hardest part of designing a good dynamic(要设计一个优秀的动态规划算法)programming algorithm from any problem, which is we're going to(意识才是最重要的)actually look not at all subsequences of x and y(这样我们就不用考虑x和y的所有子序列了),but just prefixes(而只是它们的前缀).OK, we're just going to look at prefixes and we're going to(我们要做的只是考量它们的前缀)show how we can express the length of the longest common(以及如何用这些前缀来描述)subsequence of prefixes in terms of each other(它们自己的LCS长度).In particular, we're going to define c of i j(特别的 我们定义c[i, j])to be the length, the longest common subsequence(来记录x和y的LCS长度)of the prefix of x going from one to i(x的前缀是从1到i的),and y of going to one to j(y的前缀则是从1到j).And what we are going to do is(之后我们要做的就是)we're going to calculate c[i, j] for all ij.And if we do that, how then do we solve the(如果这个完成了之后 那接下来如何)problem of the longest common of sequence of x and y(算出x和y的最长公共子序列)?And the c[m, n]is just equal to the longest common subsequence of x and y(就等于x和y的LCS).And so,it's going to turn out that what we want to do is(那么 我们要做的已经明确了)figure out how to express to c[m,n], in general(就是找到c[m,n]),in general(就是找打c[m,n]的归纳式 更一般地说)c[i,j], in terms of other c[i,j](用其他的c[i,j]来表示c[i,j]).OK, so our theorem is going to say that c[i,j] is just(于是按照这个公式 c[i,j]就等于)OK,it says that if the i-th characters matches the j-th(意思就是如果x的第i个字符)character, then i-th character of x matches the j-th(和y的第j个字符相等)character of y, then c[i,j] of ij is just(那么c[i,j]就等于)c of i minus one, j minus one plus one(c[i-1,j-1]+1).And if they don't match(如果它们不相等),then it's either going to be the longer(那c[i,j]就等于c[i,j-1]和c[i-1,j]中) of c[i,j-1]
and c[i-1,j],OK?(比较大的那一个)So that's what we're going to prove(我们将要证明它).And that's going 
--------

16. Greedy algorithms
    today, we talk about a particular class of algorithms called greedy algorithms(一类叫做贪婪算法的特殊算法).But we're going to do it in the context of graphs(但我们会涉及一些图论的知识).So, I want to review a little bit about graphs(所以 我们先回顾一下图的相关内容),which mostly you can find in the textbook in appendix B(大部分内容可以在课本的附录B里找到).So, just reminder, a digraph(只是提醒一下 一个Digraph).What's that short for(是什么的简称)?Directed graph, OK?Directed graph,G equals(V, E).OK,has a set, V, of vertices(有一个顶点集合V).and we have a set E which is a subset of V cross V of edges(是V叉乘V条边的子集).So that's a digraph(这是一个有向图).And undirected graph, E contains unordered pairs(在无向图里 E包含的是无序的顶点对).OK, so the number of edges is(那么 边的数量是)whether it's directed or undirected, is O of what(无论有向还是无向 复杂度是多少)?V^2.
    if the G is connected, we have another bound(如果G是连通的 我们就有另一个界限),the number of edges is at least the number of vertices minus one, OK(至少是顶点数减1)?So there's various ways of representing graphs in computers(计算机有很多不同的表示图的方式),and I'm just going to cover a couple of the important ones(我只讲几个比较重要的).There's actually more. We'll see some more(我们日后会看到更多的).So, the simplest one is what's called an adjacency matrix(最简单的一个 称为邻接矩阵).An adjacency matrix of the graph, G, equals (V, E)(图G=(V, E)的一个邻接矩阵),whereas simplest,I'll let V be the set of integers from one up to n(让V为从1到n的整数集),is the n by n matrix A given by the ij-th at the entry((邻接矩阵是一个n乘n的矩阵A 他的第ij项...)) is simply one if the edge, ij, is in the edge set(如果边集里存在一条边ij---则A[i, j]=1)and zero if ij is not in the edge set(如果边ij不再边集里 则为0).OK, sometimes you have edge weighted graphs(有时候 有些图的边是加权了的),and then sometimes what people will do(那么有时候人们会这样处理)is replace this by edge weights(用边的权重来替换1或0).OK, it will be the weight of the edge from i to j(它变成了边ij的权重).
    So, let's just do an example of that(举一个例子)just to make sure that our intuition corresponds(来证明我们的直觉)to our mathematical definitions(跟我们的数学定义相符).So,here's an example graph.(这是一个图利)Let's say that's our graph(假设这是我们的图).So let's just draw the adjacency the matrix(画一下它的邻接矩阵).OK, so what this says: is there's an edge from one to one(这里是什么：从1到1是否有一条边相连)?And the answer is no(答案是没有).Is there an edge from one to two?Yes(从1到2呢？有).Is there an edge from one to three here?Yep(有一条边从1到3？ 有).That's the adjacency matrix for this particular graph(这就是这个图特有的邻接矩阵).And so,I can represent a graph as this adjacency matrix(所以 我可以用邻接矩阵来表示一个图).OK,when I represent it in this way(当用这种方式表示时).how much storage do I need(需要多少存储空间)?OK, V^2.OK, and that's what we call a dense representation(这就是所说的稠密表示).OK, it works well when the graph is dense(如果图是稠密的话 它的效果非常好).So, the graph is dense if the number of edges(图是稠密的也就是说 如果边的数量)is close to all of the edges possible(很接近最大可能边数).But for many types of graphs, the number of edges(但对于大多数图来说 边的数量)is much less than the possible number of edges(都会员预案少于最大可能边数).In which case we say the graph is sparse(这种情况我们称图是稀疏的).Can somebody give me an example of a sparse graph(谁能给出一个稀疏图的例子吗)? A class of graphs(一类图):so, I want a class of graphs that as n grows(我想要一类图 在这种图里随着n的增加),the number of edges in the graph doesn't grow as the square(图内边的数量不会按n^2的比例增加). A linked list, so, a chain(一个链表 一条链).OK, if you look at it from a graph theoretically(理论上 如果从图的角度来看),is a perfectly good example only n edges in the chain(这会是一个绝佳的例子：只有n条边)for a chain of length n(存放在一条长为n的链里).So therefore, the number of edges would be order V(因此 边的数量会是O(V)).And in particular, you'd only have one edge per row here(这样一来 这里每一行都只有一条边).What other graphs are sparse(还有什么图是稀疏的)?Good, a planner graph(很好 平面图),a graph that can be drawn in a plane turns out that(一个只能在平面上画出来的图)if it has V vertices has, and V is at least three(如果它有V个顶点 而V至少是3),then it has, at most, three V minus six edges(那么 它最多只有(3V-6)条边).So, it turns out that's order V edges again(所以 结果还是O(V)条边).What's another example of a common graph(还有一种常见图的例子是什么)?Yeah, binary tree, or even actually any tree(没错 二叉树或者是其它任意树),you know, what's called a free tree if you read the appendix(如果你看过附录 你就知道那叫自由树).A tree that just is a connected graph that has no cycles(树是一种没有环的连通图)OK, is another example(这是另一个例子).What's an example of a graph that's dense(稠密图有什么例子)?A complete graph, OK: it's all ones(完全图 这里全部是1).OK, or if you have edge weights(好吧 如果边有权重的话),it would be a completely filled in matrix(这个矩阵会被完全填满).So, this is goode for dense representation(所以它很适用于稠密表示).But sometimes you want to have a sparse representation(但有时候你想要用稀疏表示)so we don't have to spend V^2 space to deal with all of the(不想花费V^2的空间来表示),where most of it's going to be zeros(因为这里很多地方都是0).OK, it's sort of like, if we know it's zero(骄傲一下 既然都是0的话),why bother representing it as zero(人家才不会写得这么麻烦呢)?
    So, one such representation is an adjacency list representation(好的 有一种方法是用邻接表来表示).Actually, adjacency list of a given vertex is the list(实际上 一个给定顶点的邻接表),which we denote by Adj of V, of vertices adjacent to V(我们用Adj(V)来表示 它记录了与V相邻的顶点).OK, just in terms by their terminology(根据它们的术语),vertices are adjacent, but edges are incident on vertices(顶点之间是邻接的 但边与顶点是关联的).OK, so the incidence is a relation between a vertex and an edge(所以 关联是指顶点与边之间的关系).An adjacency is a relation between two vertices(邻接是指两个顶点之间的关系).OK, that's just the language(这只是叫法不同).Why they use to different terms, I don't know(为什么会有不同的术语 我不知道). So, in the graph, for example(举个例子 在这个图里),the adjacency list for vertex one(顶点1的邻接表)is just the list or the set of two three(是包含2和3的链表或者集合)because one has going out of one are edges to two and three(因为从1出发的边 有一条到2  有一条到3).
