15. Dynamic Programming
    So, the topic today is dynamic programming(我们今天来讲动态规划).The term programming in the name of this term(本质上来说 这里的“编程”)doesn't refer to computer programming(并不是指实际的计算机编程).OK, programming is an old word that means(其实 编程这个名词的本意是)any tabular method for accomplishing something(按照一定的步骤来解决问题).So, you'll hear about linear programming(你们可能已经听说过线性规划)and dynamic programming(和动态规划).Either of those, even though we now incorporate(无论哪个 尽管我们现在在编程中)those algorithms in computer programs,(使用这些算法)originally computer programming(但在实际计算机编程中), you were given a datasheet and you put(你要做的是写出一行一行的)one line per line of code as a tabular method(能够按步骤执行的代码)for giving the machine instructions as to what to do.(这样电脑才会明白如何执行这项工作)OK, so the term programming is older.(这里说的“编程”是以前的表达方式了)Of course, and now conventionally when you see programming(当然 按照惯例我们说编程的时候)you mean software, computer programming.(指的是电脑程序的编程)But that wasn't always the case.(哦 严格来说倒也不一定)And these terms continue in the literature.(文献上说的编程还是将他的本意)So, dynamic programming is a design technique like other(动态规划就是一种设计的技巧)design technique we've seen such as divided and conquer.(就像我们以前讲过的分而治之法)OK, so it's a way of solving a class of problems(也就是说它是解决一类问题的方法)rather than a particular algorithms or something.(而不是某种固定的算法)
    So, we're going to work through this for the example of(所以 我们通过一个具体的例子来学习这种方法)so-called longest common subsequence problem(就是传说中的最长公共子序列问题)sometimes called LCS.which is a problem that comes up in a variety of contexts.(这个问题在很多地方都会出现)And it's particularly important in computation biology(在计算生物学里尤为重要)where you have long DNA strains and you're trying to(比如你想在一些DNA长链里)find commonalities between two strings(找到两条链里相同的部分)OK, one which may be a genome and one may be various(比如其中一段序列是基因组序列)when people do, what is that thing called(他们是用什么东西)when they do the evolutionary comparisons?(来表示演化过程的比较的？)So, you're given two sequences, x going from one to m(给定两个序列 x是从1到m)and y running from one to n(y从1到n)Usually the longest common subsequence isn't unique.(但通常 最长公共子序列并不唯一)There could be several different subsequences(可能有很多子序列).However, people tend to, it's one of the sloppinesses(不过通常情况下)that people will say.(大家都说得不太严谨).I will try to say a, unless it's unique(我习惯说“之一”除非最长公共子序列的确只有一个)
    So, here's an example.(现在来看例子吧)Suppose x is this sequence, and y is this sequence.(令x是这个序列 y是这个序列)So, what is a longest common subsequence.(所以，最长公共子序列是？)
    So let's analyze that(分析一下).what's the time of Check,Length of y, which is order n.And how do you do it?(就是y的长度O(n))，你怎么知道的？Yeah, you just scan(是的 就是扫描一遍).Now, if you will, recursively see whether(那就按x和y的下标开始递归)the suffix of your string matches the suffix of x(判断x和y里对应的元素是否相同).OK, and so, you are just simply walking down the tree(总而言之 就是顺着撸一遍)to see if it matches(看看有没有相同的).You're walking down the string to see if it matches(遍历这个字符串 看看有没有相同的).OK, then the second thing is(第二个问题是)then how many subsequences of x are there(X有多少子序列)?Two to the n(2^n)?x just goes from one to m, two to the m subsequences of x(x是从1到m 也就是说x的子序列有2^m个).Two to the m subsequences of x(x的子序列有2^m个).OK, one way to see that, you say, well(有一种方法来计算),how many subsequences are there of something there(某个序列的子序列有多少个)?If I consider a bit vector of length m(考虑一个长度为m的“位向量”实际上就是二进制数，用1和0来表示对应位上的元素).OK, that's one or zero,just every position where there's a one, I take out,(如果有一个元素被标记为1)that identifies an element that I'm going to take out(那就表示这个元素被我放进了子序列里).OK, then that gives me a mapping from each subsequence of x(这样我就可以得到一个映射 每个x的子序列)from each bit vector to a different subsequence of x(都对应了一个相应的位向量).Now, of course, you could have matching characters there(当然 有的子序列的字符可能是相同的),but in the worst case, all of the characters are different(不过在最坏情况下 所有的字符都是不一样的).OK, and so every one of thos will be a unique subsequence(那样每个子序列都是不同的).So, each bit vector of length m corresponds to a subsequence(所以每个长为m的位向量 都对应了一个子序列).So, the worst-case running time of this method(于是这个方法在最坏条件下的运行时间)is order n times two to the m, which is,(就是O(n*2^m)也就是说)since m is in the exponent, is exponential time(由于m在指数位上 运行时间也就是指数阶的).And there's a technical term that we use(我们可以用一个术语)when something is exponential time(描述指数阶时间).Slow, good.(龟速 好的)This is taking a long time to crank out(这样做需要花费相当长的时间)how long the longest common subsequence is(才能算出最长公共子序列的长度)because there's so many subsequences(因为子序列实在是太多了).OK, so we're going to now go through a process of(那么我们现在需要设计)developing a far more efficient algorithm for this problem(一种更给力的算法来解决这个问题).
    OK, and we're actually going to go through several stages(可以分为几个步骤).The first one is to go through simplification stage(第一步是进行简化).OK, and what we're going to do is look at simply(我们来分别看看)the length of the longest common sequence of x and y(x和y的LCS有多长).And then what we'll do is extend the algorithm(我们要做的就是扩展这个算法)to find the longest common subsequence itself(使之能够找到最长公共子序列).OK, so we're going to look at the length(我们从序列的长度入手).So, simplify the problem, if you will,(那么先试着简化计算)to just try to compute the length(LCS长度这个问题).What's nice is the length is unique(令人愉快的是 这个长度是唯一的).OK, there's only going to be one length(所谓的最大长度) that's going to be the longest(有且仅有一个).OK, and what we'll do is just focus on(于是我们现在要做的就是)the problem of computing the length(如何计算LCS的长度).And then we'll do is we can back up from that and figure out(然后我们再回头来看看)what actually is the subsequence that realizes that length(哪个公共子区间达到了这个长度).OK, and that will be a big simplification because we don't(这样做就简化了很多)have to keep track of a lot of different possibilities(因为我们无需在意其他的可能性)at every stage. We just have to keep track of(我们要做的就是记录)the one number,which is the length(一个最大长度的数值).So, it's sort of reduces it to a numerical problem(这样就把它简化成了一个数值问题).We'll adopt the following notation(我们会用到这样的符号).It's pretty standard notation,but I just want,(这个符号很常见 不过在这里)if I put absolute values around the string or a sequence(如果我对一个序列加了绝对值符号),it denotes the length of the sequence, S(它表示的是这个序列的长度 S).OK, so that's the first thing.The second thing we're going to(嗯这是第一点 接下来我们要做的)do is, actually, we're going to(我们要做的－－－),which takes a lot more insight when you come up with(对付这样的问题需要你的优化意识)a problem like this, and in some sense(从某种意义上来说),ends up being the hardest part of designing a good dynamic(要设计一个优秀的动态规划算法)programming algorithm from any problem, which is we're going to(意识才是最重要的)actually look not at all subsequences of x and y(这样我们就不用考虑x和y的所有子序列了),but just prefixes(而只是它们的前缀).OK, we're just going to look at prefixes and we're going to(我们要做的只是考量它们的前缀)show how we can express the length of the longest common(以及如何用这些前缀来描述)subsequence of prefixes in terms of each other(它们自己的LCS长度).In particular, we're going to define c of i j(特别的 我们定义c[i, j])to be the length, the longest common subsequence(来记录x和y的LCS长度)of the prefix of x going from one to i(x的前缀是从1到i的),and y of going to one to j(y的前缀则是从1到j).And what we are going to do is(之后我们要做的就是)we're going to calculate c[i, j] for all ij.And if we do that, how then do we solve the(如果这个完成了之后 那接下来如何)problem of the longest common of sequence of x and y(算出x和y的最长公共子序列)?And the c[m, n]is just equal to the longest common subsequence of x and y(就等于x和y的LCS).And so,it's going to turn out that what we want to do is(那么 我们要做的已经明确了)figure out how to express to c[m,n], in general(就是找到c[m,n]),in general(就是找打c[m,n]的归纳式 更一般地说)c[i,j], in terms of other c[i,j](用其他的c[i,j]来表示c[i,j]).OK, so our theorem is going to say that c[i,j] is just(于是按照这个公式 c[i,j]就等于)OK,it says that if the i-th characters matches the j-th(意思就是如果x的第i个字符)character, then i-th character of x matches the j-th(和y的第j个字符相等)character of y, then c[i,j] of ij is just(那么c[i,j]就等于)c of i minus one, j minus one plus one(c[i-1,j-1]+1).And if they don't match(如果它们不相等),then it's either going to be the longer(那c[i,j]就等于c[i,j-1]和c[i-1,j]中) of c[i,j-1]
and c[i-1,j],OK?(比较大的那一个)So that's what we're going to prove(我们将要证明它).And that's going 
