15. Dynamic Programming
    So, the topic today is dynamic programming(我们今天来讲动态规划).The term programming in the name of this term(本质上来说 这里的“编程”)doesn't refer to computer programming(并不是指实际的计算机编程).OK, programming is an old word that means(其实 编程这个名词的本意是)any tabular method for accomplishing something(按照一定的步骤来解决问题).So, you'll hear about linear programming(你们可能已经听说过线性规划)and dynamic programming(和动态规划).Either of those, even though we now incorporate(无论哪个 尽管我们现在在编程中)those algorithms in computer programs,(使用这些算法)originally computer programming(但在实际计算机编程中), you were given a datasheet and you put(你要做的是写出一行一行的)one line per line of code as a tabular method(能够按步骤执行的代码)for giving the machine instructions as to what to do.(这样电脑才会明白如何执行这项工作)OK, so the term programming is older.(这里说的“编程”是以前的表达方式了)Of course, and now conventionally when you see programming(当然 按照惯例我们说编程的时候)you mean software, computer programming.(指的是电脑程序的编程)But that wasn't always the case.(哦 严格来说倒也不一定)And these terms continue in the literature.(文献上说的编程还是将他的本意)So, dynamic programming is a design technique like other(动态规划就是一种设计的技巧)design technique we've seen such as divided and conquer.(就像我们以前讲过的分而治之法)OK, so it's a way of solving a class of problems(也就是说它是解决一类问题的方法)rather than a particular algorithms or something.(而不是某种固定的算法)
    So, we're going to work through this for the example of(所以 我们通过一个具体的例子来学习这种方法)so-called longest common subsequence problem(就是传说中的最长公共子序列问题)sometimes called LCS.which is a problem that comes up in a variety of contexts.(这个问题在很多地方都会出现)And it's particularly important in computation biology(在计算生物学里尤为重要)where you have long DNA strains and you're trying to(比如你想在一些DNA长链里)find commonalities between two strings(找到两条链里相同的部分)OK, one which may be a genome and one may be various(比如其中一段序列是基因组序列)when people do, what is that thing called(他们是用什么东西)when they do the evolutionary comparisons?(来表示演化过程的比较的？)So, you're given two sequences, x going from one to m(给定两个序列 x是从1到m)and y running from one to n(y从1到n)Usually the longest common subsequence isn't unique.(但通常 最长公共子序列并不唯一)There could be several different subsequences(可能有很多子序列).However, people tend to, it's one of the sloppinesses(不过通常情况下)that people will say.(大家都说得不太严谨).I will try to say a, unless it's unique(我习惯说“之一”除非最长公共子序列的确只有一个)
    So, here's an example.(现在来看例子吧)Suppose x is this sequence, and y is this sequence.(令x是这个序列 y是这个序列)So, what is a longest common subsequence.(所以，最长公共子序列是？)
    So let's analyze that(分析一下).what's the time of Check,Length of y, which is order n.And how do you do it?(就是y的长度O(n))，你怎么知道的？Yeah, you just scan(是的 就是扫描一遍).Now, if you will, recursively see whether(那就按x和y的下标开始递归)the suffix of your string matches the suffix of x(判断x和y里对应的元素是否相同).OK, and so, you are just simply walking down the tree(总而言之 就是顺着撸一遍)to see if it matches(看看有没有相同的).You're walking down the string to see if it matches(遍历这个字符串 看看有没有相同的).OK, then the second thing is(第二个问题是)then how many subsequences of x are there(X有多少子序列)?Two to the n(2^n)?x just goes from one to m, two to the m subsequences of x(x是从1到m 也就是说x的子序列有2^m个).Two to the m subsequences of x(x的子序列有2^m个).OK, one way to see that, you say, well(有一种方法来计算),how many subsequences are there of something there(某个序列的子序列有多少个)?If I consider a bit vector of length m(考虑一个长度为m的“位向量”实际上就是二进制数，用1和0来表示对应位上的元素).OK, that's one or zero,just every position where there's a one, I take out,(如果有一个元素被标记为1)that identifies an element that I'm going to take out(那就表示这个元素被我放进了子序列里).OK, then that gives me a mapping from each subsequence of x(这样我就可以得到一个映射 每个x的子序列)from each bit vector to a different subsequence of x(都对应了一个相应的位向量).Now, of course, you could have matching characters there(当然 有的子序列的字符可能是相同的),but in the worst case, all of the characters are different(不过在最坏情况下 所有的字符都是不一样的).OK, and so every one of thos will be a unique subsequence(那样每个子序列都是不同的).So, each bit vector of length m corresponds to a subsequence(所以每个长为m的位向量 都对应了一个子序列).So, the worst-case running time of this method(于是这个方法在最坏条件下的运行时间)is order n times two to the m, which is,(就是O(n*2^m)也就是说)since m is in the exponent, is exponential time(由于m在指数位上 运行时间也就是指数阶的).And there's a technical term that we use(我们可以用一个术语)when something is exponential time(描述指数阶时间).Slow, good.(龟速 好的)This is taking a long time to crank out(这样做需要花费相当长的时间)how long the longest common subsequence is(才能算出最长公共子序列的长度)because there's so many subsequences(因为子序列实在是太多了).OK, so we're going to now go through a process of(那么我们现在需要设计)developing a far more efficient algorithm for this problem(一种更给力的算法来解决这个问题).
    OK, and we're actually going to go through several stages(可以分为几个步骤).The first one is to go through simplification stage(第一步是进行简化).OK, and what we're going to do is look at simply(我们来分别看看)the length of the longest common sequence of x and y(x和y的LCS有多长).And then what we'll do is extend the algorithm(我们要做的就是扩展这个算法)to find the longest common subsequence itself(使之能够找到最长公共子序列).OK, so we're going to look at the length(我们从序列的长度入手).So, simplify the problem, if you will,(那么先试着简化计算)to just try to compute the length(LCS长度这个问题).What's nice is the length is unique(令人愉快的是 这个长度是唯一的).OK, there's only going to be one length(所谓的最大长度) that's going to be the longest(有且仅有一个).OK, and what we'll do is just focus on(于是我们现在要做的就是)the problem of computing the length(如何计算LCS的长度).And then we'll do is we can back up from that and figure out(然后我们再回头来看看)what actually is the subsequence that realizes that length(哪个公共子区间达到了这个长度).OK, and that will be a big simplification because we don't(这样做就简化了很多)have to keep track of a lot of different possibilities(因为我们无需在意其他的可能性)at every stage. We just have to keep track of(我们要做的就是记录)the one number,which is the length(一个最大长度的数值).So, it's sort of reduces it to a numerical problem(这样就把它简化成了一个数值问题).We'll adopt the following notation(我们会用到这样的符号).It's pretty standard notation,but I just want,(这个符号很常见 不过在这里)if I put absolute values around the string or a sequence(如果我对一个序列加了绝对值符号),it denotes the length of the sequence, S(它表示的是这个序列的长度 S).OK, so that's the first thing.The second thing we're going to(嗯这是第一点 接下来我们要做的)do is, actually, we're going to(我们要做的－－－),which takes a lot more insight when you come up with(对付这样的问题需要你的优化意识)a problem like this, and in some sense(从某种意义上来说),ends up being the hardest part of designing a good dynamic(要设计一个优秀的动态规划算法)programming algorithm from any problem, which is we're going to(意识才是最重要的)actually look not at all subsequences of x and y(这样我们就不用考虑x和y的所有子序列了),but just prefixes(而只是它们的前缀).OK, we're just going to look at prefixes and we're going to(我们要做的只是考量它们的前缀)show how we can express the length of the longest common(以及如何用这些前缀来描述)subsequence of prefixes in terms of each other(它们自己的LCS长度).In particular, we're going to define c of i j(特别的 我们定义c[i, j])to be the length, the longest common subsequence(来记录x和y的LCS长度)of the prefix of x going from one to i(x的前缀是从1到i的),and y of going to one to j(y的前缀则是从1到j).And what we are going to do is(之后我们要做的就是)we're going to calculate c[i, j] for all ij.And if we do that, how then do we solve the(如果这个完成了之后 那接下来如何)problem of the longest common of sequence of x and y(算出x和y的最长公共子序列)?And the c[m, n]is just equal to the longest common subsequence of x and y(就等于x和y的LCS).And so,it's going to turn out that what we want to do is(那么 我们要做的已经明确了)figure out how to express to c[m,n], in general(就是找到c[m,n]),in general(就是找打c[m,n]的归纳式 更一般地说)c[i,j], in terms of other c[i,j](用其他的c[i,j]来表示c[i,j]).
    OK, so our theorem is going to say that c[i,j] is just(于是按照这个公式 c[i,j]就等于)OK,it says that if the i-th characters matches the j-th(意思就是如果x的第i个字符)character, then i-th character of x matches the j-th(和y的第j个字符相等)character of y, then c[i,j] of ij is just(那么c[i,j]就等于)c of i minus one, j minus one plus one(c[i-1,j-1]+1).And if they don't match(如果它们不相等),then it's either going to be the longer(那c[i,j]就等于c[i,j-1]和c[i-1,j]中) of c[i,j-1] and c[i-1,j],OK?(比较大的那一个)So that's what we're going to prove(我们将要证明它).And that's going to give us a way of relating the calculation(这个公式告诉我们 对于给定的c[i,j])of a given cij to values that are strictly smaller(它的值是由两个严格小于它的值决定的).OK, that is at least one of the arguments is smaller of the two(这里面肯定有一个是比较小的)arguments. OK, and that's going to give us(这样我们就知道)a way of being able, then, to understand how to calculate c[i,j](如何理解c[i,j]的计算过程)So, let's prove this theorem(我们就来证明这个).So, we'll start with a case x equals y of j(从x[i]=y[j]的情况开始).
    OK,so let's see what that means(来看一下这是什么意思).OK, so let's let z of one to k be,in fact, the longest common(令最长公共子序列z[1..k])subsequence of x of one to i, y of one to j(等于LCS(x[1..i], y[1..j])),where c of ij is equal to k.OK, so the longest common(当c[i,j]=k的时候 这样的话) of subsequence of x and y of one to i and y of one to j has some(x[1..i],y[1..j]的最长公共子序列)value. Let's call it k(就等于这个k值).And so,let's say that we have some sequence which realizes(然后我们假设有一个序列达到了这个长度)that. OK,we'll call it z(我们称为z). OK,so then,can somebody tell me what z of k is(那谁来说说z[k]是什么东西)? Yeah,it's actually equal to x of i,which is also equal to y of j(是的，它确实等于x[i]也就是y[j]).Why is that(为什么是这样的)?So,the idea is,Suppose that the sequence(其实就是说 如果z这个序列)didn't include this element here at the last element(不包含最后面的这个元素),the longest common subsequence(也就是假设LCS里没有这两个字符). OK, so then it includes a bunch of values in here, and a bunch of values in here(而在这两个序列里的前面的这些字符都是相等的)same values. It doesn't include this or this(只是不包含后面这两个字符). Well, then I could just tack on this extra character(那么我就可以向这个LCS中添加这个字符)and make it be longer,make it k plus one(使其长度增加 长度变成k+1)because these two match(因为最后这两个也是相等的). OK, so if the sequence ended before(也就是说如果这个LCS还没到x[i])just extend it by tacking on x[i](那么在上面加个x[i]就可以让它更长了). OK,so if that's the case(那么接下来),then if I look at z going one up to k minus one(对于z[1..k-1]这个序列)that's a certainly common sequence of x of 1 to, excuse me, of to i minus one. And, y of one to j minus one(最长公共子序列).OK,because this is a longest common sequence(因为我们已经知道了这是一个最长公共子序列). OK,now,what you also suspect(你们还能想到些什么)?So that's what we claim, z of one to k minus one is(我要说的就是这个命题 z[1..k-1]) in fact a longest common subsequence of x of 1 to i-1(其实就是x[1..i-1]和y[1..j-1])and y of one to j-1(最长公共子序列).So, let's prove that claim(下面我们来证明这个命题).We'll just have a little diversion to prove the claim(要证明这个的绕点弯). 
    Ok,so Suppose that w is a longer common sequence(假设w是一个更长的公共子序列),that is, that the length, the w, is bigger than k-1(这也就是说w的长度要比k-1大). OK, so Suppose we have a longer common sequence than(如果存在一个公共子序列的长度)z of one to k-1. So, it's got to have length(那么这个子序列的长度)that's bigger than k-1 if it's longer(就要大于k-1).OK, and now what we do is we use a classic argument you're(接下来我们要用到一个很经典的方法)going to see multiple times, not just this week(你们将不止一次地遇见它 不仅仅是这周),which it will be important for this week(对于这周的内容它至关重要),but through several lectures(而且后面的课还会提到它).Hence, it's called a cut and paste argument(总之 它的名字是“剪贴”法).So, the idea is let's take a look at w(这个方法就是把w拿出来), concatenate it with that last character, z of k(把那个最后面的字符z[k]连结在后面).So, this is string, concatenation(把它们接在一起 连结).OK, so that's just my terminology for string(连结就是接上的术语表示).OK, so I take whatever I claimed was(我可以取一个)a longer common subsequence(更长的公共子序列),and I concatenate z of k to it(然后把z[k]和它进行连结).OK, so that is certainly a common sequence of(这个连接后的序列一定是)x of one to i, and y of one to j(x[1..i]和y[1..j]的一个公共子序列).And it has length bigger than k because it's basically(它的长度一定大于k因为－－),what is its length(它的长度是多少)?The length of w is bigger than k-1(w的长度就已经比k-1大了).I add one character(在这之上我又加了一个字符).So, this combination here, now, has length bigger that k(这里我们进行了合并 合并后的序列长度就大于k了).OK, and that's a contradiction,thereby proving the claim(于是导出了矛盾 假设不成立 原名题得证).Thus,c[i-1,j-1]equals to k-1, which implies c[i,j]=c[i-1,j-1]+1.Other cases are similar(其它类似LCS的证明过程都差不多).But, in fact, we've hit on one of(其实我们刚才讲的就是)the two hallmarks of dynamic programming(动态规划的两个特征之一).So, by hallmarks I mean when you see this kind of structure in a problem(就是当你遇到这种结构的问题时), there's a good chance that dynamic programming(十有八九是可以用动态规划) is going to work as a strategy(来解决的).
    The dynamic programming hallmark is the following(下面说的就是动态规划的特征).This is number one(下面来讲第一条).And that is the property of optimal substructure(这也是最优子结构的性质).OK, what that says is an optimal solution to a problem(意思是问题的一个最优解----), and by this, we really mean problem instance(问题是指实际的问题实例).But it's tedious to keep saying problem instance(不够一直称为“问题实例”又太文绉绉).A problem is generally, in computer science(计算机领域中所说的问题),viewed as having an infinite number of instances typically(实际上是由无数种不同的实例).OK, so sorting is a problem(比如排序就是一个问题).A sorting instance is a particular input(一个排序的实例就是一个特别的输入).OK, so we're really talking about problem instances(所以我们要处理的都是问题实例),but I'm just going to say problem(不过口头上我就叫它“问题”).So,when you have an optimal solution to a problem(那么 如果一个问题的最优解), contains optimal solutions to subproblems(包含了子问题的最优解).So,here's a example, if z is a longest common subsequence of x and y(z是x和y的LCS).OK, then any prefix of z is a longest common subsequence(那么任何z的前缀都是某个x的前缀)of a prefix of x, and a prefix of y(和某个y的前缀的LCS).OK, in this case, and the idea is that almost always(在这种结构下你总是能够----),it means that there's a cut and(在上面应用)paste argument you could do to demonstrate that(剪贴法来做出证明).OK, that if the substructure were not optimal(证明如果子问题的解不是最优的),then you'd be able to find a better solution to the overall(那么用剪贴法你总能找到)problem using cut and paste(一个全局最优解).
    OK, so this theorem,now, gives us a strategy(根据这个定理 我们可以来) for being able to compute longest common subsequence(计算LCS问题了).Here's the code(这里是代码---稍等):so going to ignore base cases in this(那就先忽略这里的初始值).And we will return the value of the longest common subsequence(返回值就是LCS的长度).It's basically just implementing this theorem(本质上就是应用前面的那个定理).OK, so it's either the longest common subsequence(它有可能就是LCS 如果x[i]和y[j])if they match(相等).It's the longest common subsequence of one of the(这时它就等于它的一个前缀+1)prefixes where you drop that character for both strengths(这个前缀是去掉末尾字符之后的LCS)and add one because that's the matching one(+1是因为去掉的那个字符就是相等).Or, you drop a character from x(如果x[i]和y[j]不等 那么在x末尾去掉一个字符), and it's the longest common subsequence of that(他就等于这个玩意的LCS).Or you drop a character from y(或者是y末尾去掉一个字符),whichever one of those is longer(这两个取最大值).That ends up being the longest common subsequence(得到的那个就是LCS). OK, so what's the worst case for this program(这个程序的最坏情况是什么)?Which of these two clauses is going to cause us more headache(这两种情况中的哪种更令我不爽)?The second clause, Why?Yeah, you're doing two LCS sub-calculations here(说的对 这里要进行两次LCS子问题的计算).Here, you're only doing one(而这种情况下你只会计算一次).Not only that, but you get to decrement both indices(还不止这样 上面那种情况两个下标都减少1),whereas here you've basically got to(而下面这种情况),you only get to decrement one index(每次只有一个下标会减少),and you've got to calculate two of them(然后还得把这两个都算一次).So that's going to generate the tree(这个过程是一个树).So, and the worst case(所以最糟的情况就是),x of i is not equal to x of j for all i and j(对于所有的i,j. x[i]不等于y[j]).So, let's draw a recursion tree for this program to(我们来画一个这个程序的递归树)get an understanding as to what is going on to help us(来理解一下它是如何工作的).
    OK, so what's the height of this tree(这个树的高度是多少)?m plus n(m加n),it's binary.So, the height: that implies the work is(所以它的高度说明运算量)exponential in m and n. All that work(是m+n的指数阶),and are we any better off than the brute force algorithm(和穷举法相比 这个算法要更好吗)?Not really(其实不然).And, our technical term for this is slow(我们对它的评价就是---龟速).OK,but I'm sure that some of you have observed(不过我想你们肯定已经察觉到)something interesting about this tree(这个树有些很奇妙的特性).Yeah, there's a lot of repeated work here(是的 有很多运算是重复的).In particular, this whole subtree(尤其是这里 这里的整个子树),and this whole subtree.OK, they are the same(还有这边的子树 它们是完全一样的).They are the same subproblem that you are solving(也就是你要解决的相同子问题).
    So, that brings up our second hallmark for dynamic programming(于是 接下来动态规划的第二特性就闪亮登场了)And that's a property called overlapping subproblems(这个特性叫做重叠子问题).OK, recursive solution contains(一个递归的过程包含)contains a small number of distinct subproblems repeated many times(独立的子问题被反复计算了多次).But how many distinct subproblems are there(那么有多少独立的子问题)?m times n(m*n).OK, and then this is a small number compared with(这个数字显得微不足道)two to the m plus n, or two to the n(相比较于2^(m+n)或者是2^n).OK, because for each subproblem(因为在每个子问题中),it's characterized by an i and a j(这个树是由i和j来表示的).An i goes from one to m(i是从1到m),j goes from one to n.So, here's an improved algorithm(这是一个改进版的算法),which is often a good way to solve it(是个解决问题的好方法).It's an algorithm called a memo-ization algorithm(这个算法叫做备忘录).And, this is memo-ization, not memorization because(注意 这备忘法而不是记忆法)what you're going to do is make a little memo(你要做的就是在计算子问题的时候)whenever you solve a subproblem(用备忘的方式记录一下).Make a little memo that says I solved this already(做备忘的意思就是我已经算完了).OK, here's the code(好的 这是它的代码).It's very similar to that code(和那个代码很像).Otherwise, just return it(算过了 就返回).How much time does it take to execute this(花费多少时间来执行它)?It takes order MN(是的 花费是O(mn)).OK, why is that(这是为什么)?There is another way to look at it that's kind of(你也可以这么想 它是一种)what you are expressing there is an amortized(按你的说法是平摊的方式),a bookkeeping, way of looking at this(记帐方法 来看这个问题).What's the amortized cost(平摊代价是多少)?You could say what the amortized cost of calculating(比如说这几个调用)one of these, where basically whenever I call it(当它们中的某一个) I'm going to charge a constant amount for looking up(我想让每一次的调用 都话费同样运算量).

--------
16. Greedy algorithms
    today, we talk about a particular class of algorithms called greedy algorithms(一类叫做贪婪算法的特殊算法).But we're going to do it in the context of graphs(但我们会涉及一些图论的知识).So, I want to review a little bit about graphs(所以 我们先回顾一下图的相关内容),which mostly you can find in the textbook in appendix B(大部分内容可以在课本的附录B里找到).So, just reminder, a digraph(只是提醒一下 一个Digraph).What's that short for(是什么的简称)?Directed graph, OK?Directed graph,G equals(V, E).OK,has a set, V, of vertices(有一个顶点集合V).and we have a set E which is a subset of V cross V of edges(是V叉乘V条边的子集).So that's a digraph(这是一个有向图).And undirected graph, E contains unordered pairs(在无向图里 E包含的是无序的顶点对).OK, so the number of edges is(那么 边的数量是)whether it's directed or undirected, is O of what(无论有向还是无向 复杂度是多少)?V^2.
    if the G is connected, we have another bound(如果G是连通的 我们就有另一个界限),the number of edges is at least the number of vertices minus one, OK(至少是顶点数减1)?So there's various ways of representing graphs in computers(计算机有很多不同的表示图的方式),and I'm just going to cover a couple of the important ones(我只讲几个比较重要的).There's actually more. We'll see some more(我们日后会看到更多的).So, the simplest one is what's called an adjacency matrix(最简单的一个 称为邻接矩阵).An adjacency matrix of the graph, G, equals (V, E)(图G=(V, E)的一个邻接矩阵),whereas simplest,I'll let V be the set of integers from one up to n(让V为从1到n的整数集),is the n by n matrix A given by the ij-th at the entry((邻接矩阵是一个n乘n的矩阵A 他的第ij项...)) is simply one if the edge, ij, is in the edge set(如果边集里存在一条边ij---则A[i, j]=1)and zero if ij is not in the edge set(如果边ij不再边集里 则为0).OK, sometimes you have edge weighted graphs(有时候 有些图的边是加权了的),and then sometimes what people will do(那么有时候人们会这样处理)is replace this by edge weights(用边的权重来替换1或0).OK, it will be the weight of the edge from i to j(它变成了边ij的权重).
    So, let's just do an example of that(举一个例子)just to make sure that our intuition corresponds(来证明我们的直觉)to our mathematical definitions(跟我们的数学定义相符).So,here's an example graph.(这是一个图利)Let's say that's our graph(假设这是我们的图).So let's just draw the adjacency the matrix(画一下它的邻接矩阵).OK, so what this says: is there's an edge from one to one(这里是什么：从1到1是否有一条边相连)?And the answer is no(答案是没有).Is there an edge from one to two?Yes(从1到2呢？有).Is there an edge from one to three here?Yep(有一条边从1到3？ 有).That's the adjacency matrix for this particular graph(这就是这个图特有的邻接矩阵).And so,I can represent a graph as this adjacency matrix(所以 我可以用邻接矩阵来表示一个图).OK,when I represent it in this way(当用这种方式表示时).how much storage do I need(需要多少存储空间)?OK, V^2.OK, and that's what we call a dense representation(这就是所说的稠密表示).OK, it works well when the graph is dense(如果图是稠密的话 它的效果非常好).So, the graph is dense if the number of edges(图是稠密的也就是说 如果边的数量)is close to all of the edges possible(很接近最大可能边数).But for many types of graphs, the number of edges(但对于大多数图来说 边的数量)is much less than the possible number of edges(都会员预案少于最大可能边数).In which case we say the graph is sparse(这种情况我们称图是稀疏的).Can somebody give me an example of a sparse graph(谁能给出一个稀疏图的例子吗)? A class of graphs(一类图):so, I want a class of graphs that as n grows(我想要一类图 在这种图里随着n的增加),the number of edges in the graph doesn't grow as the square(图内边的数量不会按n^2的比例增加). A linked list, so, a chain(一个链表 一条链).OK, if you look at it from a graph theoretically(理论上 如果从图的角度来看),is a perfectly good example only n edges in the chain(这会是一个绝佳的例子：只有n条边)for a chain of length n(存放在一条长为n的链里).So therefore, the number of edges would be order V(因此 边的数量会是O(V)).And in particular, you'd only have one edge per row here(这样一来 这里每一行都只有一条边).What other graphs are sparse(还有什么图是稀疏的)?Good, a planner graph(很好 平面图),a graph that can be drawn in a plane turns out that(一个只能在平面上画出来的图)if it has V vertices has, and V is at least three(如果它有V个顶点 而V至少是3),then it has, at most, three V minus six edges(那么 它最多只有(3V-6)条边).So, it turns out that's order V edges again(所以 结果还是O(V)条边).What's another example of a common graph(还有一种常见图的例子是什么)?Yeah, binary tree, or even actually any tree(没错 二叉树或者是其它任意树),you know, what's called a free tree if you read the appendix(如果你看过附录 你就知道那叫自由树).A tree that just is a connected graph that has no cycles(树是一种没有环的连通图)OK, is another example(这是另一个例子).What's an example of a graph that's dense(稠密图有什么例子)?A complete graph, OK: it's all ones(完全图 这里全部是1).OK, or if you have edge weights(好吧 如果边有权重的话),it would be a completely filled in matrix(这个矩阵会被完全填满).So, this is goode for dense representation(所以它很适用于稠密表示).But sometimes you want to have a sparse representation(但有时候你想要用稀疏表示)so we don't have to spend V^2 space to deal with all of the(不想花费V^2的空间来表示),where most of it's going to be zeros(因为这里很多地方都是0).OK, it's sort of like, if we know it's zero(骄傲一下 既然都是0的话),why bother representing it as zero(人家才不会写得这么麻烦呢)?
    So, one such representation is an adjacency list representation(好的 有一种方法是用邻接表来表示).Actually, adjacency list of a given vertex is the list(实际上 一个给定顶点的邻接表),which we denote by Adj of V, of vertices adjacent to V(我们用Adj(V)来表示 它记录了与V相邻的顶点).OK, just in terms by their terminology(根据它们的术语),vertices are adjacent, but edges are incident on vertices(顶点之间是邻接的 但边与顶点是关联的).OK, so the incidence is a relation between a vertex and an edge(所以 关联是指顶点与边之间的关系).An adjacency is a relation between two vertices(邻接是指两个顶点之间的关系).OK, that's just the language(这只是叫法不同).Why they use to different terms, I don't know(为什么会有不同的术语 我不知道). So, in the graph, for example(举个例子 在这个图里),the adjacency list for vertex one(顶点1的邻接表)is just the list or the set of two three(是包含2和3的链表或者集合)because one has going out of one are edges to two and three(因为从1出发的边 有一条到2  有一条到3).The adjacency list for two is just three(2的邻接表只有3).For three is the empty set, and for four, it is three(3的邻接表是个空集 4的邻接表是3).So that's the representation(这是这个表示方法).Now, if we want to figure out how much storage(如果想要知道这种表示法)is required for this representation(需要占用多少存储空间的话).We need to understand how long the adjacency list is(那就必须先知道这个邻接表有多长).So, what is the length of an adjacency list of a vertex, V(对于一个顶点V 其邻接表的长度是多少)?What name do we give to that(我们用什么名词来描述)?

---------
20. Parallel algorithms
    So the last, we only have four more lectures left, and what Professor Demmaine and I have decided to do is give two series of lectures on sort of advanced topics.So, today and Wednesday we're going to(那么 我们准备在今天和星期三)talk about parallel algorithms(讨论并行算法), algorithms where you have more than one processor(这种算法会用到多个处理器)whacking away on your problem(并行地解决问题) . And this is a very hot topic right now(这个课题最近非常火) because all of the chip manufactures(因为现在的那些芯片制造商) are now producing so-called multicore processors(都在生产所谓的多核处理器) where you have more than one processor per chip(每个芯片都有多于一个处理器). So, knowing something about that is good(所以 多了解这些知识有好处). The second topic we're going to cover is going to be caching, (我们的第二个算法是关于缓存)and how you design algorithms for systems with cache(以及如何为有缓存机制的系统设计算法). Right now, we're sort of program to everything(目前来说 我们在编程时) as if it were just a single level of memory(都只用了单一的一层内存), and for some problems(但对于某些问题)that's not an entirely realistic model(这跟现实的模型不完全一样).You'd like to have some model(现实中你用到的模型) for how the caching hierarchy works(需要考虑多级缓存怎么运作), and how you can take advantage of that(以及怎么利用好多层缓存). And there's been a lot of research in that area as well(这个领域人们也已经做了很多研究). So, both of those actually(其实 这两个课题)turn out to be my area of research(都在我的研究范围内). That's fun to me(那对我很有趣).
    So, today we'll talk about parallel algorithms(那么 我们今天讨论的是并行算法).  And the particular topic, it turns out that(关于这个课题 实际上)there are lots of models for parallel algorithms(我们有许多种不同的并行算法模型), and for parallelism(和并行化模型).And it's one of the reasons that(这样的原因是), whereas for serial algorithms(对于串行算法而言),most people sort of have this basic model(人们一般只有一种基础模型)that we've been using(也就我们用的那种). It's sometimes called a random access machine model(他有时候被称为随机存取机器模型),which is what we've been using to analyze things(我们之前的分析就是基于这个模型),whereas in the parallel space(但是在并行的空间里),there's just a huge number of models(还有很多其它的模型),and there is no general agreement(而且还没有一个共识)on what is the best model(认为哪一个才是最佳模型) because there are different machines(因为不同的模型)that are made with different configuratios, etc(它们有不同的构造).And people haven't, sort of, agreed on(而且人们甚至还没确定),even how parallel machines should be organized.(并行模型应该如何组织)So, we're going to deal with a paraticular model(那么 我们准备研究一种并行模型),which goes under the rubric of dynamic multithreading(它是属于动态多线程的一种),which is appropriate for the multicore machines(适合用于多核机器中) that are now being built for shared memory programming(它是为内存共享的编程而设计的).It's not appropriate for what's called(并不适用于所谓的)distributed memory programs particularly(分布式内存编程) because the processors are able to access things(因为每个处理器都有访问内存的权限).And for those, you need more involved models(对于其他的情况 你需要学习更多相关的模型).And so, let me start just by giving an example of(所以 让我们从一个简单的例子开始)how one would write something(看看怎么写并行程序).I'm going to give you a program(我准备给你一个程序) for calculating the nth Fibonacci number in this model(这是用来计算第n个斐波拉起数的模型).This is actually a really bad algorithms(其实我接下来要讲的)which is given you because it's going to be the exponential time algorithms(因为它的复杂度是指数级的),whereas we know from week one or two that you can(然而我们在前两周就学会了)calculate the nth Fibonacci number in how much time?(计算Fibonacci数要花多少时间？)log n time. So, this is two exponentials off of(log n的时间 节省了两个指数)what you should be able to get,(这才是你应该得到的结构 节省了两个指数)OK, two exponentials off.OK, so here's the code(所以 这是代码).OK, so this is essentially the pseudocode we would write(好的 这个就是我们要写的伪代码).
    And let me just explain a little bit about(我来解释一下),we have a couple of key words here we haven't seen before:(有几个关键词我们从没有见过)in particular, spawn and sync(特别是衍生(spawn)和同步(sync)).OK, so spawn, this basically says that(这个衍生其实就是指)the subroutine that you're calling(你正在调用一个子程序), you use it as a keyword before a subroutine,(你把衍生作为一个关键字加在子程序前)that it can execute at the same time as its parent(这样它就跟父程序同时执行).So here, what we say x equals spawn of fib of n minus one(这里 我们说x=spawn fib(n-1))we immediately go onto the next statement(我们立刻转到下一语句).And now, while we're executing fib of n minus one,(现在当我们在计算fib(n-1)的时候)we can also be executing, now,(我们同时也在执行...)this statement which itself will spawn something off(下面这条语句 它本身也会衍生子程序).OK, and we continue, and then we hit the sync statement.(好的 我们继续 然后我们碰到这个同步语句)And, what sync says is,(同步就是说)wait until all children are done.(等待至所有子程序完成)OK,so it says once you get to this point(所以一旦你运行到这里),you've got to wait until everything here has completed(你需要等到所有子程序完成后)before you execute the x plus y(才能继续执行这个x+y)because otherwise you're going to(否则的话 你就要)try to execute the calculation(用还没算出来的x和y)of x plus y without having computed it yet.(来执行x+y这个运算)OK,so that's the basic structure(好的 这就是它的基础结构).What this describes, notice in here we never said(这是说...注意了 我们还未曾说过)how many processors or anything we are running on(我们要用到多少处理器神马的).OK, so this actually is(好吧 这实际上)just describing logical parallelism(只是描述了并行的逻辑)--not the actual parallelism when we execute it.(而不是我们实际的并行化执行)And so,what we need is a scheduler to determine(所以 我们要用到一个调度器来决定)how to map this dynamically unfolding execution(如何把这个动态的 不断延伸的程序)onto whatever processors you have available.(映射到可用的处理器上)OK, so today actually,(好的今天实际上)we're going to talk mostly about scheduling.(我们会集中讲关于调度的内容)and then, next time we're going to talk about(然后下一次 我们就会讨论)specific application algorithms(一些特定的应用算法), and how you analyze them(以及如何去分析它们).So you can view the actual multithreaded computation(那时 你们就能看到真真的多线程计算).If you take a look at the parallel instruction stream(如果你看过并行指令就知道),it's just a directed acyclic graph, OK?(它其实是一个有向非循环图)So, let me show you how that works.(那么 我来讲讲它是怎么工作的)
