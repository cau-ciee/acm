　　So, the topic today is dynamic programming(我们今天来讲动态规划).The
term programming in the name of this term(本质上来说 这里的“编程”)doesn't
refer to computer programming(并不是指实际的计算机编程).OK, programming is
an old word that means(其实 编程这个名词的本意是)any tabular method for
accomplishing something(按照一定的步骤来解决问题).So, you'll hear about linear programming(你们可能已经听说过线性规划)and dynamic programming(和动态规划).Either of those, even though we now incorporate(无论哪个 尽管我们现在在编程中)those algorithms in computer programs,(使用这些算法)originally computer programming(但在实际计算机编程中), you were given a datasheet and you put(你要做的是写出一行一行的)one line per line of code as a tabular method(能够按步骤执行的代码)for giving the machine instructions as to what to do.(这样电脑才会明白如何执行这项工作)OK, so the term programming is older.(这里说的“编程”是以前的表达方式了)Of course, and now conventionally when you see programming(当然 按照惯例我们说编程的时候)you mean software, computer programming.(指的是电脑程序的编程)But that wasn't always the case.(哦 严格来说倒也不一定)And these terms continue in the literature.(文献上说的编程还是将他的本意)So, dynamic programming is a design technique like other(动态规划就是一种设计的技巧)design technique we've seen such as divided and conquer.(就像我们以前讲过的分而治之法)OK, so it's a way of solving a class of problems(也就是说它是解决一类问题的方法)rather than a particular algorithms or something.(而不是某种固定的算法).<br />
　　So, we're going to work through this for the example of(所以 我们通过一个具体的例子来学习这种方法)so-called longest common subsequence problem(就是传说中的最长公共子序列问题)sometimes called LCS.which is a problem that comes up in a variety of contexts.(这个问题在很多地方都会出现)And it's particularly important in computation biology(在计算生物学里尤为重要)where you have long DNA strains and you're trying to(比如你想在一些DNA长链里)find commonalities between two strings(找到两条链里相同的部分)OK, one which may be a genome and one may be various(比如其中一段序列是基因组序列)when people do, what is that thing called(他们是用什么东西)when they do the evolutionary comparisons?(来表示演化过程的比较的？)So, you're given two sequences, x going from one to m(给定两个序列 x是从1到m)and y running from one to n(y从1到n)Usually the longest common subsequence isn't unique.(但通常 最长公共子序列并不唯一)There could be several different subsequences(可能有很多子序列).However, people tend to, it's one of the sloppinesses(不过通常情况下)that people will say.(大家都说得不太严谨).I will try to say a, unless it's unique(我习惯说“之一”除非最长公共子序列的确只有一个).<br />
　　So, here's an example.(现在来看例子吧)Suppose x is this sequence, and y is this sequence.(令x是这个序列 y是这个序列)So, what is a longest common subsequence.(所以，最长公共子序列是？)<br />
　　So let's analyze that(分析一下).what's the time of Check,Length of y, which is order n.And how do you do it?(就是y的长度O(n))，你怎么知道的？Yeah, you just scan(是的 就是扫描一遍).Now, if you will, recursively see whether(那就按x和y的下标开始递归)the suffix of your string matches the suffix of x(判断x和y里对应的元素是否相同).OK, and so, you are just simply walking down the tree(总而言之 就是顺着撸一遍)to see if it matches(看看有没有相同的).You're walking down the string to see if it matches(遍历这个字符串 看看有没有相同的).OK, then the second thing is(第二个问题是)then how many subsequences of x are there(X有多少子序列)?Two to the n(2^n)?x just goes from one to m, two to the m subsequences of x(x是从1到m 也就是说x的子序列有2^m个).Two to the m subsequences of x(x的子序列有2^m个).OK, one way to see that, you say, well(有一种方法来计算),how many subsequences are there of something there(某个序列的子序列有多少个)?If I consider a bit vector of length m(考虑一个长度为m的“位向量”实际上就是二进制数，用1和0来表示对应位上的元素).OK, that's one or zero,just every position where there's a one, I take out,(如果有一个元素被标记为1)that identifies an element that I'm going to take out(那就表示这个元素被我放进了子序列里).OK, then that gives me a mapping from each subsequence of x(这样我就可以得到一个映射 每个x的子序列)from each bit vector to a different subsequence of x(都对应了一个相应的位向量).Now, of course, you could have matching characters there(当然 有的子序列的字符可能是相同的),but in the worst case, all of the characters are different(不过在最坏情况下 所有的字符都是不一样的).OK, and so every one of thos will be a unique subsequence(那样每个子序列都是不同的).So, each bit vector of length m corresponds to a subsequence(所以每个长为m的位向量 都对应了一个子序列).So, the worst-case running time of this method(于是这个方法在最坏条件下的运行时间)is order n times two to the m, which is,(就是O(n*2^m)也就是说)since m is in the exponent, is exponential time(由于m在指数位上 运行时间也就是指数阶的).And there's a technical term that we use(我们可以用一个术语)when something is exponential time(描述指数阶时间).Slow, good.(龟速 好的)This is taking a long time to crank out(这样做需要花费相当长的时间)how long the longest common subsequence is(才能算出最长公共子序列的长度)because there's so many subsequences(因为子序列实在是太多了).OK, so we're going to now go through a process of(那么我们现在需要设计)developing a far more efficient algorithm for this problem(一种更给力的算法来解决这个问题).<br />
　　OK, and we're actually going to go through several stages(可以分为几个步骤).The first one is to go through simplification stage(第一步是进行简化).OK, and what we're going to do is look at simply(我们来分别看看)the length of the longest common sequence of x and y(x和y的LCS有多长).And then what we'll do is extend the algorithm(我们要做的就是扩展这个算法)to find the longest common subsequence itself(使之能够找到最长公共子序列).OK, so we're going to look at the length(我们从序列的长度入手).So, simplify the problem, if you will,(那么先试着简化计算)to just try to compute the length(LCS长度这个问题).What's nice is the length is unique(令人愉快的是 这个长度是唯一的).OK, there's only going to be one length(所谓的最大长度) that's going to be the longest(有且仅有一个).OK, and what we'll do is just focus on(于是我们现在要做的就是)the problem of computing the length(如何计算LCS的长度).And then we'll do is we can back up from that and figure out(然后我们再回头来看看)what actually is the subsequence that realizes that length(哪个公共子区间达到了这个长度).OK, and that will be a big simplification because we don't(这样做就简化了很多)have to keep track of a lot of different possibilities(因为我们无需在意其他的可能性)at every stage. We just have to keep track of(我们要做的就是记录)the one number,which is the length(一个最大长度的数值).So, it's sort of reduces it to a numerical problem(这样就把它简化成了一个数值问题).We'll adopt the following notation(我们会用到这样的符号).It's pretty standard notation,but I just want,(这个符号很常见 不过在这里)if I put absolute values around the string or a sequence(如果我对一个序列加了绝对值符号),it denotes the length of the sequence, S(它表示的是这个序列的长度 S).OK, so that's the first thing.The second thing we're going to(嗯这是第一点 接下来我们要做的)do is, actually, we're going to(我们要做的－－－),which takes a lot more insight when you come up with(对付这样的问题需要你的优化意识)a problem like this, and in some sense(从某种意义上来说),ends up being the hardest part of designing a good dynamic(要设计一个优秀的动态规划算法)programming algorithm from any problem, which is we're going to(意识才是最重要的)actually look not at all subsequences of x and y(这样我们就不用考虑x和y的所有子序列了),but just prefixes(而只是它们的前缀).OK, we're just going to look at prefixes and we're going to(我们要做的只是考量它们的前缀)show how we can express the length of the longest common(以及如何用这些前缀来描述)subsequence of prefixes in terms of each other(它们自己的LCS长度).In particular, we're going to define c of i j(特别的 我们定义c[i, j])to be the length, the longest common subsequence(来记录x和y的LCS长度)of the prefix of x going from one to i(x的前缀是从1到i的),and y of going to one to j(y的前缀则是从1到j).And what we are going to do is(之后我们要做的就是)we're going to calculate c[i, j] for all ij.And if we do that, how then do we solve the(如果这个完成了之后 那接下来如何)problem of the longest common of sequence of x and y(算出x和y的最长公共子序列)?And the c[m, n]is just equal to the longest common subsequence of x and y(就等于x和y的LCS).And so,it's going to turn out that what we want to do is(那么 我们要做的已经明确了)figure out how to express to c[m,n], in general(就是找到c[m,n]),in general(就是找打c[m,n]的归纳式 更一般地说)c[i,j], in terms of other c[i,j](用其他的c[i,j]来表示c[i,j]).<br />
　　OK, so our theorem is going to say that c[i,j] is just(于是按照这个公式 c[i,j]就等于)OK,it says that if the i-th characters matches the j-th(意思就是如果x的第i个字符)character, then i-th character of x matches the j-th(和y的第j个字符相等)character of y, then c[i,j] of ij is just(那么c[i,j]就等于)c of i minus one, j minus one plus one(c[i-1,j-1]+1).And if they don't match(如果它们不相等),then it's either going to be the longer(那c[i,j]就等于c[i,j-1]和c[i-1,j]中) of c[i,j-1] and c[i-1,j],OK?(比较大的那一个)So that's what we're going to prove(我们将要证明它).And that's going to give us a way of relating the calculation(这个公式告诉我们 对于给定的c[i,j])of a given cij to values that are strictly smaller(它的值是由两个严格小于它的值决定的).OK, that is at least one of the arguments is smaller of the two(这里面肯定有一个是比较小的)arguments. OK, and that's going to give us(这样我们就知道)a way of being able, then, to understand how to calculate c[i,j](如何理解c[i,j]的计算过程)So, let's prove this theorem(我们就来证明这个).So, we'll start with a case x equals y of j(从x[i]=y[j]的情况开始).<br />
　　OK,so let's see what that means(来看一下这是什么意思).OK, so let's let z of one to k be,in fact, the longest common(令最长公共子序列z[1..k])subsequence of x of one to i, y of one to j(等于LCS(x[1..i], y[1..j])),where c of ij is equal to k.OK, so the longest common(当c[i,j]=k的时候 这样的话) of subsequence of x and y of one to i and y of one to j has some(x[1..i],y[1..j]的最长公共子序列)value. Let's call it k(就等于这个k值).And so,let's say that we have some sequence which realizes(然后我们假设有一个序列达到了这个长度)that. OK,we'll call it z(我们称为z). OK,so then,can somebody tell me what z of k is(那谁来说说z[k]是什么东西)? Yeah,it's actually equal to x of i,which is also equal to y of j(是的，它确实等于x[i]也就是y[j]).Why is that(为什么是这样的)?So,the idea is,Suppose that the sequence(其实就是说 如果z这个序列)didn't include this element here at the last element(不包含最后面的这个元素),the longest common subsequence(也就是假设LCS里没有这两个字符). OK, so then it includes a bunch of values in here, and a bunch of values in here(而在这两个序列里的前面的这些字符都是相等的)same values. It doesn't include this or this(只是不包含后面这两个字符). Well, then I could just tack on this extra character(那么我就可以向这个LCS中添加这个字符)and make it be longer,make it k plus one(使其长度增加 长度变成k+1)because these two match(因为最后这两个也是相等的). OK, so if the sequence ended before(也就是说如果这个LCS还没到x[i])just extend it by tacking on x[i](那么在上面加个x[i]就可以让它更长了). OK,so if that's the case(那么接下来),then if I look at z going one up to k minus one(对于z[1..k-1]这个序列)that's a certainly common sequence of x of 1 to, excuse me, of to i minus one. And, y of one to j minus one(最长公共子序列).OK,because this is a longest common sequence(因为我们已经知道了这是一个最长公共子序列). OK,now,what you also suspect(你们还能想到些什么)?So that's what we claim, z of one to k minus one is(我要说的就是这个命题 z[1..k-1]) in fact a longest common subsequence of x of 1 to i-1(其实就是x[1..i-1]和y[1..j-1])and y of one to j-1(最长公共子序列).So, let's prove that claim(下面我们来证明这个命题).We'll just have a little diversion to prove the claim(要证明这个的绕点弯). <br />
　　Ok,so Suppose that w is a longer common sequence(假设w是一个更长的公共子序列),that is, that the length, the w, is bigger than k-1(这也就是说w的长度要比k-1大). OK, so Suppose we have a longer common sequence than(如果存在一个公共子序列的长度)z of one to k-1. So, it's got to have length(那么这个子序列的长度)that's bigger than k-1 if it's longer(就要大于k-1).OK, and now what we do is we use a classic argument you're(接下来我们要用到一个很经典的方法)going to see multiple times, not just this week(你们将不止一次地遇见它 不仅仅是这周),which it will be important for this week(对于这周的内容它至关重要),but through several lectures(而且后面的课还会提到它).Hence, it's called a cut and paste argument(总之 它的名字是“剪贴”法).So, the idea is let's take a look at w(这个方法就是把w拿出来), concatenate it with that last character, z of k(把那个最后面的字符z[k]连结在后面).So, this is string, concatenation(把它们接在一起 连结).OK, so that's just my terminology for string(连结就是接上的术语表示).OK, so I take whatever I claimed was(我可以取一个)a longer common subsequence(更长的公共子序列),and I concatenate z of k to it(然后把z[k]和它进行连结).OK, so that is certainly a common sequence of(这个连接后的序列一定是)x of one to i, and y of one to j(x[1..i]和y[1..j]的一个公共子序列).And it has length bigger than k because it's basically(它的长度一定大于k因为－－),what is its length(它的长度是多少)?The length of w is bigger than k-1(w的长度就已经比k-1大了).I add one character(在这之上我又加了一个字符).So, this combination here, now, has length bigger that k(这里我们进行了合并 合并后的序列长度就大于k了).OK, and that's a contradiction,thereby proving the claim(于是导出了矛盾 假设不成立 原名题得证).Thus,c[i-1,j-1]equals to k-1, which implies c[i,j]=c[i-1,j-1]+1.Other cases are similar(其它类似LCS的证明过程都差不多).But, in fact, we've hit on one of(其实我们刚才讲的就是)the two hallmarks of dynamic programming(动态规划的两个特征之一).So, by hallmarks I mean when you see this kind of structure in a problem(就是当你遇到这种结构的问题时), there's a good chance that dynamic programming(十有八九是可以用动态规划) is going to work as a strategy(来解决的).<br />
　　The dynamic programming hallmark is the following(下面说的就是动态规划的特征).This is number one(下面来讲第一条).And that is the property of optimal substructure(这也是最优子结构的性质).OK, what that says is an optimal solution to a problem(意思是问题的一个最优解----), and by this, we really mean problem instance(问题是指实际的问题实例).But it's tedious to keep saying problem instance(不够一直称为“问题实例”又太文绉绉).A problem is generally, in computer science(计算机领域中所说的问题),viewed as having an infinite number of instances typically(实际上是由无数种不同的实例).OK, so sorting is a problem(比如排序就是一个问题).A sorting instance is a particular input(一个排序的实例就是一个特别的输入).OK, so we're really talking about problem instances(所以我们要处理的都是问题实例),but I'm just going to say problem(不过口头上我就叫它“问题”).So,when you have an optimal solution to a problem(那么 如果一个问题的最优解), contains optimal solutions to subproblems(包含了子问题的最优解).So,here's a example, if z is a longest common subsequence of x and y(z是x和y的LCS).OK, then any prefix of z is a longest common subsequence(那么任何z的前缀都是某个x的前缀)of a prefix of x, and a prefix of y(和某个y的前缀的LCS).OK, in this case, and the idea is that almost always(在这种结构下你总是能够----),it means that there's a cut and(在上面应用)paste argument you could do to demonstrate that(剪贴法来做出证明).OK, that if the substructure were not optimal(证明如果子问题的解不是最优的),then you'd be able to find a better solution to the overall(那么用剪贴法你总能找到)problem using cut and paste(一个全局最优解).<br />
　　OK, so this theorem,now, gives us a strategy(根据这个定理 我们可以来) for being able to compute longest common subsequence(计算LCS问题了).Here's the code(这里是代码---稍等):so going to ignore base cases in this(那就先忽略这里的初始值).And we will return the value of the longest common subsequence(返回值就是LCS的长度).It's basically just implementing this theorem(本质上就是应用前面的那个定理).OK, so it's either the longest common subsequence(它有可能就是LCS 如果x[i]和y[j])if they match(相等).It's the longest common subsequence of one of the(这时它就等于它的一个前缀+1)prefixes where you drop that character for both strengths(这个前缀是去掉末尾字符之后的LCS)and add one because that's the matching one(+1是因为去掉的那个字符就是相等).Or, you drop a character from x(如果x[i]和y[j]不等 那么在x末尾去掉一个字符), and it's the longest common subsequence of that(他就等于这个玩意的LCS).Or you drop a character from y(或者是y末尾去掉一个字符),whichever one of those is longer(这两个取最大值).That ends up being the longest common subsequence(得到的那个就是LCS). OK, so what's the worst case for this program(这个程序的最坏情况是什么)?Which of these two clauses is going to cause us more headache(这两种情况中的哪种更令我不爽)?The second clause, Why?Yeah, you're doing two LCS sub-calculations here(说的对 这里要进行两次LCS子问题的计算).Here, you're only doing one(而这种情况下你只会计算一次).Not only that, but you get to decrement both indices(还不止这样 上面那种情况两个下标都减少1),whereas here you've basically got to(而下面这种情况),you only get to decrement one index(每次只有一个下标会减少),and you've got to calculate two of them(然后还得把这两个都算一次).So that's going to generate the tree(这个过程是一个树).So, and the worst case(所以最糟的情况就是),x of i is not equal to x of j for all i and j(对于所有的i,j. x[i]不等于y[j]).So, let's draw a recursion tree for this program to(我们来画一个这个程序的递归树)get an understanding as to what is going on to help us(来理解一下它是如何工作的).<br />
　　OK, so what's the height of this tree(这个树的高度是多少)?m plus n(m加n),it's binary.So, the height: that implies the work is(所以它的高度说明运算量)exponential in m and n. All that work(是m+n的指数阶),and are we any better off than the brute force algorithm(和穷举法相比 这个算法要更好吗)?Not really(其实不然).And, our technical term for this is slow(我们对它的评价就是---龟速).OK,but I'm sure that some of you have observed(不过我想你们肯定已经察觉到)something interesting about this tree(这个树有些很奇妙的特性).Yeah, there's a lot of repeated work here(是的 有很多运算是重复的).In particular, this whole subtree(尤其是这里 这里的整个子树),and this whole subtree.OK, they are the same(还有这边的子树 它们是完全一样的).They are the same subproblem that you are solving(也就是你要解决的相同子问题).<br />
　　So, that brings up our second hallmark for dynamic programming(于是 接下来动态规划的第二特性就闪亮登场了)And that's a property called overlapping subproblems(这个特性叫做重叠子问题).OK, recursive solution contains(一个递归的过程包含)contains a small number of distinct subproblems repeated many times(独立的子问题被反复计算了多次).But how many distinct subproblems are there(那么有多少独立的子问题)?m times n(m*n).OK, and then this is a small number compared with(这个数字显得微不足道)two to the m plus n, or two to the n(相比较于2^(m+n)或者是2^n).OK, because for each subproblem(因为在每个子问题中),it's characterized by an i and a j(这个树是由i和j来表示的).An i goes from one to m(i是从1到m),j goes from one to n.So, here's an improved algorithm(这是一个改进版的算法),which is often a good way to solve it(是个解决问题的好方法).It's an algorithm called a memo-ization algorithm(这个算法叫做备忘录).And, this is memo-ization, not memorization because(注意 这备忘法而不是记忆法)what you're going to do is make a little memo(你要做的就是在计算子问题的时候)whenever you solve a subproblem(用备忘的方式记录一下).Make a little memo that says I solved this already(做备忘的意思就是我已经算完了).OK, here's the code(好的 这是它的代码).It's very similar to that code(和那个代码很像).Otherwise, just return it(算过了 就返回).<br />
　　How much time does it take to execute this(花费多少时间来执行它)?It takes order MN(是的 花费是O(mn)).OK, why is that(这是为什么)?There is another way to look at it that's kind of(你也可以这么想 它是一种)what you are expressing there is an amortized(按你的说法是平摊的方式),a bookkeeping, way of looking at this(记帐方法 来看这个问题).What's the amortized cost(平摊代价是多少)?You could say what the amortized cost of calculating(比如说这几个调用)one of these, where basically whenever I call it(当它们中的某一个) I'm going to charge a constant amount for looking up(我想让每一次的调用 都花费同样运算量).And so, I could get to look up whatever is in here(这样我要找这里的结果时).But if it, in fact, so in some sense, this charge here(某种意义上来说 ),of calling it and returning it(这几条语句是调用的花费).I charge that to my caller(我向它们收取调用和返回的费用).And I charge the rest of these lines to the c[i,j] element(然后中间这几行是c[i,j]的花费).And then, the point is that every caller basically only(要注意的是 基本上每一次的调用)ends up being charged for a constant amount of stuff(其花费都是常数量).OK, to calculate one c[i,j], it's only an amortized(所以计算一个c[i,j] 平摊起来)constant amount of stuff that I'm charging to that(我也只需要常数量的运算) calculating of i and j, that calculation of i and j(我对一个c[i,j]的花费就这么多).OK, so you can view it in terms of(你可以把它看成)amortized analysis doing a bookkeeping argument that just says(用记帐方法来进行平摊分析).Let me charge enough to calculate my own(每个计算单元 我都收够一定的费用),do all my own local things plus enough to(来支付这一步的操作 再加上)look up the value in the next level and get it returned(支付查看下一层元素和返回的操作).OK, and then if it has to go off and calculate(即使它真的要继续往下运算).well, that's OK because that's all been(那也无所谓 因为这些花费)charged to a different ij at that point(会由另外的ij来负责).So, every cell only costs me a constant amount of time(所以 每个计算单元都只花费常数量的时间)that order MN cells total of order constant work per entry(在O(mn)中 每次都花费常数量的计算).OK, and you can sort of use(你可以用)an amortized analysis to argue that(平摊分析来证明它).How much space does it take(它的空间花费是多少)?We haven't usually looked at space(我们一般不关注空间),but here we are going to start looking at space(但这里我们的开始看看空间的问题了).That turns out, for some of these algorithms(对于一些算法来说)to be really important(空间是很重要的).How much space do I need, storage space(我需要多少空间？存储空间？)?Yeah, also m times n, OK, to store the c[i,j] table(是的 也是m乘n 就是存储c[i,j]的表).OK, the rest, storing x and y(剩下的用来存储x和y的).OK, that's just m plus n(只有m+n那么多).So, that's negligible(可以忽略不计了),but mostly I need the space m times n(我需要的空间大概就是m乘n那么多).So, this memo-ization type algorithm is a really good(所以备忘法的算法)strategy in programming for many things where(在编程中是很有用的策略),when you have the same parameters(当你有相同传入的参数),you're going to get the same results(你就会得到相同的结果).It doesn't work in programs where you have(当然它也有不管用的时候)a side effect, necessarily, that is(那就是当你的运算),when the calculation for a given set of parameters(有很多传入参数)might be different on each call(都是不一样的时候).But for something which isessentially like a(不过对于这种)functional programming type of environment(函数式的编程),then if you've calculated it once, you can look it up(如果你已经计算过一组参数的结果 那直接查找就好了).But, it takes a fair amount of space(然而 它也花费了相当多的空间),and it also doesn't proceed in a very orderly way(而且在空间上也不是很整齐的).So, there is another strategy for doing(所以有另一种策略来解决重复运算)exactly the same calculation in a bottom-up way(就是用自底向上的方法).And that's what we call dynamic programming(这才是传说中的真动态规划).OK, the idea is to compute the table bottom-up(主要思想就是自底向上地计算表格).<br />
　　What we're going to do is look at the c[i,j] table and realize that there's actually an orderly(然后意识到其实可以按照一定顺序)way of filling in the table(来填这个表).This is sort of a top-down with memo-ization(前面讲的是自顶向下的备忘法).OK, but there's actually a way(不过实际上还有一种方式)we can do it bottom up(我们可以自底向上地来做).So, here's the idea(我们来看一下).So, let's make our table(这是我们的表格).OK, so there's x(这是x).so there's y(这是y).And, I'm going to initialize the empty string(我需要西安对这些空项进行初始化).I didn't cover the base cases for c[i,j](我没有覆盖掉c[i,j]的初始值),but c of zero meaning a prefix with no elements in it(c[0]的含义就是一个没有任何元素的前缀).The prefix of that without anything else, the length is zero(这个前缀里面什么都没有 它的长度也就是0).OK, so that's basically how I'm going to bound the borders here(画出这些只是要划定一个边界).From this character in y(从y里的这个字符开始), and this character in x up to this character(还有x里的这个字符).So here, for example, they don't match(比如说这里 它们不相等).So, it's the maximum of these two values(于是它等于这两个的最大值).Here, they do match(这里它们相等了).OK, so it says it's one plus the value here(它就等于1加上左上方这个数).And so, all I'm doing is applying that recusive formula(然后我要做的就是应用哪个递归公式)from the theorem that we proved(就是我们证明过的定理里的那个).So here, it's basically they don't match(这里它们不相等).So, it's the maximum of those two(所以是两个的最大值).Here, they match(这里相等了).So, it's one plus that guy(所以是1加上这货 这里不相等).So, it's basically the maximum of these two(就是那两个的最大值).So this is blindingly fast code if you code this up(显而易见 这是很快的代码).OK, because it gets to use the fact that modern machines in(因为这用到了现代机器的一个性质)particular do very well on regular strides through memory(如果对内存的操作是有规律的 那他们通常很给力).So, if you're just plowing through memory across like this(如果你按这个顺序使用内存),and your two-dimensional array is stored in that order(这个二维数组就是按这种顺序存下来),which it is, otherwise you go this way(否则的话就是按这种顺序),stored in that order(按这种顺序存储的).So, how much time did it take us to do this(那么 我们花了多少时间来干这个)?<br />
　　Yeah, order MN, theta MN(是的O(mn)).We'll talk about space in just a minute(我们稍后就将空间的问题).And basically, I do that(我要做的是).I can reconstruct the longest common subsequence(通过回溯法重建LCS)by tracing backwards(通过回溯法重建LCS).So essentially I start here(所以我从这里出发).Here I have a choice because this one was dependent on(这里我做了一次选择).And this was just one path back(当然这只是一种路径).I could have gone a path like this and(我也可以不走寻常路)gotten a different longest common subsequence(得到一个截然不同的LCS).OK, so that simplification of just saying(这种简化其实就是在说),let me just run backwards and figure it out(我只是往回走了几步就能找出LCS),that's actually pretty good because it means(这是相当不错的 因为这意味着)that by just calculating the value(在计算的过程中),then figuring out these back pointers to(用这些反向指针)let me reconstruct it is a fairly simple process(来重建LCS其实是很容易的).OK, if I had to think about that to begin with(如果我想从前向后建立LCS),it would have been a much bigger mess(那将会困难重重).OK, so the space, I just mentioned(那么接着我刚才说的 空间问题),was order MN because we still need the table(是O(mn)因为我们还是要用到这个表格).But you can actually do the min of m and n(其实用O(m, n)的空间就能解决问题).How?First of all(那么首先),let's just do this existing algorithm(我们就从这个算法入手).If I just simply did row by row(如果我按行来做),I don't need more than a previous row(我不需要前一行的数据).OK, I just need one row at a time(每次只需要一行就够了).So, I can go ahead and compute just one row(我可以只用一行计算)because once I computed the succeeding row(因为一旦我算出了后面的行).the first row is unimportant(第一行就无关紧要).And in fact, I don't even need the whole row(其实我都不需要这整个行).All I need is just the current row that I'm on(我需要的只有现在我用的这一行),plus one or two elements of the previous row(和上一行的一两个元素),plus the end of the previous row(还有上一行的末尾).So, I use a prefix of this row,and an extra two elements(所以我用到了这一行的前缀 还有上一行两个元素).and the suffix of this row(还有上一行的末尾).So, it's actually, you can do it with one row(实际上 你需要的只有一行),plus order one element(加上O(1)这么多的元素).And then, I could do it either running vertically or running(我可以选择是横向还是纵向)horizontally, whichever one gives me the smaller space(哪样省空间我就选哪样).<br />
　　On the homework, we're going to look at a(作业里面 你们会看到一个问题)problem called the edit distance problem(叫做编辑距离问题).Edit distance is you are given two strings(编辑距离问题是给定你两个).A keyboard with one of the strings there(你用一个上面只有一串字母的键盘打字).And what you have to do is by doing inserts, and deletes(你所能做的就是插入 删除),and replace, and moving the cursor around(替换 还得移动光标),you've got to transform one string to the next(你要把这个字符串变形成另一个).And, each of those operations has a cost(每次这种操作都有代价).And your job is to minimize the cost of(你的任务就是)transforming the one string into the other(将这种变形的计算量减到最小).And, in fact, there have been editors(而且 还有各种编辑器也会用到它), screen editors, text editors(像影片编辑器 文本编辑器),that implement algorithms of this nature in order to minimize(都要用这样的算法来使)the number of characters that have to be sent(发送到系统的I/O数据最小化)as IO in and out of the system(发送到系统的I/O数据最小化).So, the warning is, you better get going on your programming(提醒你们一下 你们最好)
